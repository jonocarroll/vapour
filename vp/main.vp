# lists
list(1, 2, 3)
list(1, "2", 3.2)
list(x = 1, "2")
list(x = 1, "2", list(NA))
list(NA, 2, "2", list(NA))

# vectors
c(1, 2, NA, 3)
c(1, 2, 3)
c(1L, 2L, 3L)
c(1.2, 1, 2.2)

# dataframe
data.frame(x = c(1, 2), y = c(2, 3))
data.frame(x = 1L)
data.frame(x = c(1,2), y = NA)

# structure
structure(1, class = "data")
structure(1, y = c(2, 3), class = "data")
structure(1, class = "numeric")
structure(1, y = c(2, 3), class = c("numeric", "data"))

# factors!

# matrix

type numeric = int | float

let x: int = 1

let y: float = 2.2

func add(x: numeric, y: numeric): numeric{
  return x + y
}

let total: numeric = add(x, y)

print(total)

// vector
type v []int

// list
// list(x = c(1,2,3))
type namedList list {
  x: int 
}

// list
// list(1, "2", 3.2)
type unnameList []int | []float | []string

// dataframe
// data.frame(x = c(1, 2), y = c(2, 3))
type df dataframe {
  x: int 
  y: int
}

// struct 
// structure(1, y = c(2, 3), class = "data")
type structure struct {
  int 
  y: int
}

// struct 
// structure(1, y = list(2, 3), class = "data")
type structure struct {
  int 
  y: []int
}

// type inference where possible
let ds = dataset(data{x = 1}, data{x = 2}, data{x = 3})

create_dataset = func(): dataset {
  let x: int = vector(1, 2, 3)

  // change shorthand from \(){} to () => {} from JS
  // more readable
  let ds: dataset = lapply(x, (value) => {
    data{x: value}
  })

  return ds
}

// translates to 
// add.dataset <- function(ds) ...
func (ds: dataset) add(): int {
  let x: dataset
  for (d in ds) {
    x = append(x, d$x)
  }

  sum(x)
}

let ds3: dataset = create_dataset()

type df dataframe {
  x: int
  y: int
}

func create_df(): df {
  let x: int = vector(1, 2, 3)
  let y: int = vector(4, 5, 6)
  return df(x = x, y = y)
}

df = create_df()

total = sum(df$x)

func factory(): function {
  return func(x: int): int {
    return x + 1
  }
}

type intIntake func(int): int

func factory(): inIntake {
  return func(x: int): int {
    return x + 1
  }
}
